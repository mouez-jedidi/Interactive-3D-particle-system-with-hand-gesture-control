<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestural Particle System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #00ffcc;
            --secondary: #ff006e;
            --accent: #8338ec;
            --bg-dark: #0a0e27;
            --bg-medium: #1a1f3a;
            --text-bright: #ffffff;
            --text-dim: #8b9dc3;
        }
        
        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-bright);
            overflow: hidden;
            height: 100vh;
        }
        
        /* Animated gradient background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(131, 56, 236, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(255, 0, 110, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(0, 255, 204, 0.05) 0%, transparent 50%);
            animation: bgShift 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes bgShift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(5deg); }
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video {
            display: none;
        }
        
        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 58, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(0, 255, 204, 0.3);
            border-radius: 16px;
            padding: 24px;
            z-index: 1000;
            max-width: 320px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: slideInLeft 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .panel-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        
        .section {
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            font-weight: 700;
        }
        
        /* Template Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .template-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 16px 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .template-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .template-btn:hover {
            transform: translateY(-4px);
            border-color: var(--primary);
            box-shadow: 0 8px 20px rgba(0, 255, 204, 0.3);
        }
        
        .template-btn:hover::before {
            opacity: 0.1;
        }
        
        .template-btn.active {
            background: rgba(0, 255, 204, 0.15);
            border-color: var(--primary);
            box-shadow: 
                0 0 20px rgba(0, 255, 204, 0.4),
                inset 0 0 20px rgba(0, 255, 204, 0.1);
        }
        
        .template-icon {
            font-size: 24px;
            position: relative;
            z-index: 1;
        }
        
        .template-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            z-index: 1;
        }
        
        /* Color Picker */
        .color-picker-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        #colorPicker {
            width: 60px;
            height: 60px;
            border: 3px solid var(--primary);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 255, 204, 0.3);
        }
        
        #colorPicker:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 255, 204, 0.5);
        }
        
        .preset-colors {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            flex: 1;
        }
        
        .preset-color {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .preset-color:hover {
            transform: scale(1.15);
            border-color: var(--text-bright);
        }
        
        /* Camera Toggle */
        .camera-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .toggle-switch {
            position: relative;
            width: 56px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: var(--text-bright);
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .toggle-switch.active {
            background: var(--primary);
            box-shadow: 0 0 12px rgba(0, 255, 204, 0.5);
        }
        
        .toggle-switch.active::after {
            left: 31px;
        }
        
        /* Status Indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 58, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 1000;
            animation: slideInRight 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-dim);
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status-dot.active {
            background: var(--primary);
            box-shadow: 0 0 12px var(--primary);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-size: 14px;
            font-weight: 700;
        }
        
        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 31, 58, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 0, 110, 0.3);
            border-radius: 12px;
            padding: 16px 24px;
            z-index: 1000;
            animation: slideInBottom 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-align: center;
            max-width: 600px;
        }
        
        @keyframes slideInBottom {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        .instructions-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        
        .instructions-text {
            font-size: 12px;
            color: var(--text-dim);
            line-height: 1.6;
        }
        
        /* Loading Animation */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            text-align: center;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 255, 204, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading.hidden {
            display: none;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .control-panel {
                max-width: 280px;
                padding: 16px;
            }
            
            .template-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .instructions {
                bottom: 10px;
                left: 10px;
                right: 10px;
                transform: none;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas Container -->
    <div id="canvas-container"></div>
    
    <!-- Video Element for Camera -->
    <video id="video" width="640" height="480" autoplay></video>
    
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Particle System...</div>
    </div>
    
    <!-- Control Panel -->
    <div class="control-panel">
        <div class="panel-header">‚ö° CONTROL NEXUS</div>
        
        <!-- Template Selection -->
        <div class="section">
            <div class="section-title">Particle Templates</div>
            <div class="template-grid">
                <div class="template-btn active" data-template="heart">
                    <div class="template-icon">üíñ</div>
                    <div class="template-label">Heart</div>
                </div>
                <div class="template-btn" data-template="flower">
                    <div class="template-icon">üå∏</div>
                    <div class="template-label">Flower</div>
                </div>
                <div class="template-btn" data-template="saturn">
                    <div class="template-icon">ü™ê</div>
                    <div class="template-label">Saturn</div>
                </div>
                <div class="template-btn" data-template="buddha">
                    <div class="template-icon">üßò</div>
                    <div class="template-label">Buddha</div>
                </div>
                <div class="template-btn" data-template="fireworks">
                    <div class="template-icon">üéÜ</div>
                    <div class="template-label">Fireworks</div>
                </div>
                <div class="template-btn" data-template="sphere">
                    <div class="template-icon">‚ö´</div>
                    <div class="template-label">Sphere</div>
                </div>
            </div>
        </div>
        
        <!-- Color Picker -->
        <div class="section">
            <div class="section-title">Particle Color</div>
            <div class="color-picker-wrapper">
                <input type="color" id="colorPicker" value="#00ffcc">
                <div class="preset-colors">
                    <div class="preset-color" style="background: #00ffcc;" data-color="#00ffcc"></div>
                    <div class="preset-color" style="background: #ff006e;" data-color="#ff006e"></div>
                    <div class="preset-color" style="background: #8338ec;" data-color="#8338ec"></div>
                    <div class="preset-color" style="background: #ffbe0b;" data-color="#ffbe0b"></div>
                    <div class="preset-color" style="background: #00f5ff;" data-color="#00f5ff"></div>
                    <div class="preset-color" style="background: #ff006e;" data-color="#ff006e"></div>
                    <div class="preset-color" style="background: #06ffa5;" data-color="#06ffa5"></div>
                    <div class="preset-color" style="background: #ffffff;" data-color="#ffffff"></div>
                </div>
            </div>
        </div>
        
        <!-- Camera Control -->
        <div class="section">
            <div class="section-title">Hand Tracking</div>
            <div class="camera-toggle">
                <span>Enable Camera</span>
                <div class="toggle-switch" id="cameraToggle"></div>
            </div>
        </div>
    </div>
    
    <!-- Status Indicator -->
    <div class="status-indicator">
        <div class="status-dot" id="statusDot"></div>
        <div class="status-text" id="statusText">Camera Inactive</div>
    </div>
    
    <!-- Instructions -->
    <div class="instructions">
        <div class="instructions-title">üñêÔ∏è GESTURE CONTROLS</div>
        <div class="instructions-text">
            Show one hand to camera ‚Ä¢ Move hand left/right & up/down to rotate particles ‚Ä¢ Open palm to expand ‚Ä¢ Close fist to contract ‚Ä¢ Experiment with gestures!
        </div>
    </div>
    
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, particles, particleSystem;
        let currentTemplate = 'heart';
        let currentColor = 0x00ffcc;
        let targetScale = 1.0;
        let currentScale = 1.0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let currentRotationX = 0;
        let currentRotationY = 0;
        let cameraActive = false;
        let hands, videoElement, cameraUtils;
        let handOpen = false;
        
        // Initialize Three.js Scene
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0e27, 0.002);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 30;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00ffcc, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // Create initial particle system
            createParticleSystem(currentTemplate);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').classList.add('hidden');
        }
        
        // Create particle system based on template
        function createParticleSystem(template) {
            // Remove existing particle system
            if (particleSystem) {
                scene.remove(particleSystem);
                particles.dispose();
            }
            
            let positions;
            let particleCount;
            
            switch(template) {
                case 'heart':
                    positions = generateHeartShape(2000);
                    particleCount = 2000;
                    break;
                case 'flower':
                    positions = generateFlowerShape(3000);
                    particleCount = 3000;
                    break;
                case 'saturn':
                    positions = generateSaturnShape(2500);
                    particleCount = 2500;
                    break;
                case 'buddha':
                    positions = generateBuddhaShape(4000);
                    particleCount = 4000;
                    break;
                case 'fireworks':
                    positions = generateFireworksShape(5000);
                    particleCount = 5000;
                    break;
                case 'sphere':
                    positions = generateSphereShape(3000);
                    particleCount = 3000;
                    break;
                default:
                    positions = generateSphereShape(3000);
                    particleCount = 3000;
            }
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            // Create material
            const material = new THREE.PointsMaterial({
                color: currentColor,
                size: 0.15,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // Create particle system
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            particles = geometry;
        }
        
        // Generate heart shape
        function generateHeartShape(count) {
            const positions = [];
            
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const u = Math.random() * Math.PI * 2;
                const r = Math.random() * 5;
                
                // Heart equation
                const x = r * (16 * Math.pow(Math.sin(t), 3));
                const y = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                const z = r * Math.sin(u) * 3;
                
                positions.push(x * 0.3, y * 0.3, z * 0.3);
            }
            
            return positions;
        }
        
        // Generate flower shape
        function generateFlowerShape(count) {
            const positions = [];
            const petals = 8;
            
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const r = Math.random() * 5 * (1 + 0.5 * Math.sin(petals * t));
                const theta = Math.random() * Math.PI * 2;
                
                const x = r * Math.cos(t);
                const y = r * Math.sin(t);
                const z = Math.random() * 3 - 1.5;
                
                positions.push(x, y, z);
            }
            
            return positions;
        }
        
        // Generate Saturn shape
        function generateSaturnShape(count) {
            const positions = [];
            const planetCount = Math.floor(count * 0.6);
            const ringCount = count - planetCount;
            
            // Planet sphere
            for (let i = 0; i < planetCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 5 + Math.random() * 2;
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                positions.push(x, y, z);
            }
            
            // Rings
            for (let i = 0; i < ringCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = 8 + Math.random() * 4;
                const y = (Math.random() - 0.5) * 0.5;
                
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                
                positions.push(x, y, z);
            }
            
            return positions;
        }
        
        // Generate Buddha shape (sitting meditation pose approximation)
        function generateBuddhaShape(count) {
            const positions = [];
            
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const u = Math.random() * Math.PI;
                const r = Math.random() * 8;
                
                // Create a sitting figure approximation
                let x = r * Math.sin(u) * Math.cos(t);
                let y = r * (Math.cos(u) * 0.5 + Math.abs(Math.sin(u * 2)) * 5);
                let z = r * Math.sin(u) * Math.sin(t);
                
                // Add some noise for organic feel
                x += (Math.random() - 0.5) * 1;
                y += (Math.random() - 0.5) * 1;
                z += (Math.random() - 0.5) * 1;
                
                positions.push(x, y, z);
            }
            
            return positions;
        }
        
        // Generate fireworks shape
        function generateFireworksShape(count) {
            const positions = [];
            const burstCount = 8;
            const particlesPerBurst = Math.floor(count / burstCount);
            
            for (let b = 0; b < burstCount; b++) {
                const centerX = (Math.random() - 0.5) * 20;
                const centerY = (Math.random() - 0.5) * 20;
                const centerZ = (Math.random() - 0.5) * 20;
                
                for (let i = 0; i < particlesPerBurst; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * 5;
                    
                    const x = centerX + r * Math.sin(phi) * Math.cos(theta);
                    const y = centerY + r * Math.sin(phi) * Math.sin(theta);
                    const z = centerZ + r * Math.cos(phi);
                    
                    positions.push(x, y, z);
                }
            }
            
            return positions;
        }
        
        // Generate sphere shape
        function generateSphereShape(count) {
            const positions = [];
            
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 8 + Math.random() * 2;
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                positions.push(x, y, z);
            }
            
            return positions;
        }
        
        // Update particle color
        function updateParticleColor(color) {
            currentColor = parseInt(color.replace('#', '0x'));
            if (particleSystem) {
                particleSystem.material.color.setHex(currentColor);
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (particleSystem) {
                // Smooth scale transition
                currentScale += (targetScale - currentScale) * 0.1;
                particleSystem.scale.set(currentScale, currentScale, currentScale);
                
                // Smooth rotation transition based on hand orientation
                currentRotationX += (targetRotationX - currentRotationX) * 0.15;
                currentRotationY += (targetRotationY - currentRotationY) * 0.15;
                
                particleSystem.rotation.x = currentRotationX;
                particleSystem.rotation.y = currentRotationY;
            }
            
            renderer.render(scene, camera);
        }
        
        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize MediaPipe Hands
        function initHandTracking() {
            videoElement = document.getElementById('video');
            
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandsResults);
            
            const cameraInstance = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraInstance.start();
        }
        
        // Process hand tracking results
        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 1) {
                const hand = results.multiHandLandmarks[0];
                
                // Get key landmarks
                const wrist = hand[0];           // Wrist
                const thumbTip = hand[4];        // Thumb tip
                const indexTip = hand[8];        // Index finger tip
                const pinkyTip = hand[20];       // Pinky tip
                const middleFinger = hand[12];   // Middle finger tip
                
                // Calculate hand openness (distance between thumb and pinky)
                const dx = thumbTip.x - pinkyTip.x;
                const dy = thumbTip.y - pinkyTip.y;
                const dz = thumbTip.z - pinkyTip.z;
                const palmDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                // Map palm openness to scale (open hand = larger, closed = smaller)
                targetScale = 0.5 + palmDistance * 8;
                targetScale = Math.max(0.3, Math.min(2.5, targetScale));
                
                // Calculate hand rotation based on wrist and middle finger positions
                // Horizontal rotation (Y-axis) based on X position
                const handCenterX = (wrist.x + middleFinger.x) / 2;
                targetRotationY = (handCenterX - 0.5) * Math.PI * 2; // -180¬∞ to +180¬∞
                
                // Vertical rotation (X-axis) based on Y position
                const handCenterY = (wrist.y + middleFinger.y) / 2;
                targetRotationX = (handCenterY - 0.5) * Math.PI; // -90¬∞ to +90¬∞
                
                // Check if hand is open or closed
                handOpen = palmDistance > 0.15;
                
                // Update status
                document.getElementById('statusDot').classList.add('active');
                document.getElementById('statusText').textContent = handOpen ? 
                    'Hand Open - Rotating' : 'Hand Closed - Contracting';
            } else {
                // Reset to default if hand not detected
                targetScale = 1.0;
                targetRotationX = 0;
                targetRotationY = 0;
                document.getElementById('statusDot').classList.remove('active');
                document.getElementById('statusText').textContent = 'Searching for Hand...';
            }
        }
        
        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Three.js
            initThreeJS();
            
            // Template buttons
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.template-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTemplate = btn.dataset.template;
                    createParticleSystem(currentTemplate);
                });
            });
            
            // Color picker
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                updateParticleColor(e.target.value);
            });
            
            // Preset colors
            document.querySelectorAll('.preset-color').forEach(preset => {
                preset.addEventListener('click', () => {
                    const color = preset.dataset.color;
                    document.getElementById('colorPicker').value = color;
                    updateParticleColor(color);
                });
            });
            
            // Camera toggle
            document.getElementById('cameraToggle').addEventListener('click', () => {
                const toggle = document.getElementById('cameraToggle');
                cameraActive = !cameraActive;
                
                if (cameraActive) {
                    toggle.classList.add('active');
                    initHandTracking();
                    document.getElementById('statusText').textContent = 'Camera Active';
                    document.getElementById('statusDot').classList.add('active');
                } else {
                    toggle.classList.remove('active');
                    if (videoElement && videoElement.srcObject) {
                        videoElement.srcObject.getTracks().forEach(track => track.stop());
                    }
                    targetScale = 1.0;
                    document.getElementById('statusText').textContent = 'Camera Inactive';
                    document.getElementById('statusDot').classList.remove('active');
                }
            });
        });
    </script>
</body>
</html>